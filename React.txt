What is React?

React is javascript lib for building user interfaces.

User interface:

1.Desktop client
2.Browser based apps
3.Mobile apps
4.TV,Watch...

React focus for many ui technologies.

React is used now a days 
1.browser apps -React DOM - react.js
2.Mobile apps -React Native

React focus is less code,declarative.

React is built on many design patterns and principles
 =>Flex Design pattern.
 =>Component driven design

React tech stack.
 ES 6,HTML5,CSS 3
 JSX - lanaguage created by face book in order built declarative user interface.


ES 6:
 let const
 literals
 functional programming -higher order function
 object based programming features - objects,literals,classes,destructuring
 async programming features - callbacks,promises,async..await..

Types of User interface app development types (react apps):
1.Single page web app - spa
2.Full Stack /SSR - Server side rendering - Next.js / 
3.JAMStack/SSG (Static Site Generation) -Static content -Next.js/ Gatsby

Tools chains:
 To build different types of react apps we have tools.

1.create-react-app  - spa
2.Neutrino
3.Nx
4.Parcel
5.Razzle
6.Vite

When to select what tool?

if you are building spa - create-react-app
if you are building server-rendered app with node.js - next.js - nx
if you are building ssg apps - gatsby

package management tools

1.npm
2.npx
3.yarn

Project setup
Node.js
vs code

Create Project:
E:\session\pratian\dec22\ReactSession>npx create-react-app myapp


Components:
 Object, having properties and behaviours and user interface.
Componets are organized as tree -  compoent tree.

How to create components?

1.variable pattern
import React from 'react'
import ReactDOM from 'react-dom/client';

//variable pattern 
const Greeter = <h1>Greet</h1>



const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(Greeter);


2.functional pattern
import React from 'react'
import ReactDOM from 'react-dom/client';

// function Greeter() {
//     return <h1>Greeter</h1>
// }

// const Greeter = () => {
//     return <h1>Greeter</h1>
// }
const Greeter = () => <h1>Greeter</h1>

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Greeter />);

3.class pattern
import React from 'react'
import ReactDOM from 'react-dom/client';

// es 6 class 
class Greeter extends React.Component {
    render() {
        return <h1>Greeter!!</h1>
    }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Greeter />);


Note:
 Now a days we never use class components only functional components.

....................................................................................
			Component Composition: Compoent tree model
....................................................................................

if you understand , html structure, you can understand component tree model.

Block of Ui:


<div>
<div>
  <div>
    <h1>Rice Atta & Dal<h1>	
  </div>
  <div>
    <h1>Rice Atta & Dal<h1>	
  </div>
<div>
<div>
  Recommendations
</div>
<div>
</div>

</div>

Component tree / Object tree

Header - Component -  User Interface---| Data - Biz logic
Adv - Component
Body -Component
 <Products> -Component
   <Category>
     <h1>Fresh Items
   </Category>
 </Products>

<Footer>

Project Structuring:
...................

src
 |
 components
  |
 assets
 models
 services
 
....................................................................................

Components are saved fileName.js / FileName.jsx - jsx is recommended

Note: 
 Inside root dir, App  /index /any component cant be saved as "jsx".

 index.js or App.js 

Barrel Export:
.............

folder
  -file1.js /jsx
  -file2.js
  -file3.js
  -file4.js

Without barrel export
when you import from another file

import {something} from './folder/file1'
import {something} from './folder/file2'
import {something} from './folder/file3'

With barrel export


folder
  -file1.js /jsx
  -file2.js
  -file3.js
  -file4.js
  -index.js

folder/index.js
 import { ProductList } from './products-list'
import { ProductRecommendation } from './productrecommendation'

//re export -barrel export

export { ProductList, ProductRecommendation }


src/
 index.js or any where you import.
.....................................................................................
				Data binding
.....................................................................................

User interface types:

1.static user interface
   having only html
2.dynamic user interface
  data and html

Data binding:
............
 {variable/expression/literal}
data can be primitive /object/array.


Data can be passed in react two ways

1.From outside component - props pattern
2.Within Component - state pattern

Props pattern : data is passed from parent to child component - one way data flow/Flex pattern.

Props Pattern:
import React from 'react';
import ReactDOM from 'react-dom/client';

//Child component
//all parameters are received by a component as a single literal object which is called property or props
const Greeter = (props) => {
    console.log(props)
    return <h1>{props.message} {props.name}</h1>
}

//Parent Component
const App = () => {
    //imperative style:Not recommended to call function like this 
    // return Greeter('Subramanian')
    //jsx syntax: declartive style
    return <div>
        <Greeter name="Subramanian" message="Hello" />
        <Greeter name="Karthik" message="Hi" />
    </div>
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);


..................................................................................

import React from 'react';
import ReactDOM from 'react-dom/client';

// const Profile = props => {
//     return <div>
//         <h1>Id : {props.id}</h1>
//         <p>Name : {props.name}</p>
//         <p>Status : {props.status ? "Available" : "Not Available"}</p>
//         <p>Address</p>
//         <address>
//             <p>{props.address.street}</p>
//             <p>{props.address.city}</p>
//             <p>{props.address.state}</p>
//         </address>
//     </div>
// }

//using object destructuring
// const Profile = props => {
//     const { id, name, status, address: { city, street, state } } = props
//     return <div>
//         <h1>Id : {id}</h1>
//         <p>Name : {name}</p>
//         <p>Status : {status ? "Available" : "Not Available"}</p>
//         <p>Address</p>
//         <address>
//             <p>{street}</p>
//             <p>{city}</p>
//             <p>{state}</p>
//         </address>
//     </div>
// }

const Profile = ({ id, name, status, address: { city, street, state } }) => <div>
    <h1>Id : {id}</h1>
    <p>Name : {name}</p>
    <p>Status : {status ? "Available" : "Not Available"}</p>
    <p>Address</p>
    <address>
        <p>{street}</p>
        <p>{city}</p>
        <p>{state}</p>
    </address>
</div>


//Parent Component
const App = () => {
    const address = {
        street: '10th street',
        city: 'Coimbatore',
        state: 'Tamil Nadu'
    }
    return <div>
        <Profile id={1} name="Subramanian" status={true} address={address} />
        <Profile id={2} name="Subramanian" status={true} address={address} />
        <Profile id={3} name="Subramanian" status={true} address={address} />
    </div>
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

.................................................................................
import React from 'react';
import ReactDOM from 'react-dom/client';

const Profile = props => {
    return <div>
        <h1>Id : {props.id}</h1>
        <p>Name : {props.name}</p>
        <p>Status : {props.status ? "Available" : "Not Available"}</p>
        <p>Address</p>
        <address>
            <p>{props.address.street}</p>
            <p>{props.address.city}</p>
            <p>{props.address.state}</p>
        </address>
    </div>
}
//default Props 
Profile.defaultProps = {
    id: 0,
    name: 'default',
    status: false,
    address: {
        street: 'street',
        city: 'city',
        state: 'state'
    }
}




//using object destructuring
// const Profile = props => {
//     const { id, name, status, address: { city, street, state } } = props
//     return <div>
//         <h1>Id : {id}</h1>
//         <p>Name : {name}</p>
//         <p>Status : {status ? "Available" : "Not Available"}</p>
//         <p>Address</p>
//         <address>
//             <p>{street}</p>
//             <p>{city}</p>
//             <p>{state}</p>
//         </address>
//     </div>
// }

// const Profile = ({ id, name, status, address: { city, street, state } }) => <div>
//     <h1>Id : {id}</h1>
//     <p>Name : {name}</p>
//     <p>Status : {status ? "Available" : "Not Available"}</p>
//     <p>Address</p>
//     <address>
//         <p>{street}</p>
//         <p>{city}</p>
//         <p>{state}</p>
//     </address>
// </div>


//Parent Component
const App = () => {
    const address = {
        street: '10th street',
        city: 'Coimbatore',
        state: 'Tamil Nadu'
    }
    return <div>
        {/* <Profile id={1} name="Subramanian" status={true} address={address} /> */}
        <Profile />
        <Profile id={1} name="Subramanian" status={true} address={address} />
        <Profile id={2} name="Ram" status={true} />

    </div>
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

...................................................................................
		How to break the big UI into smaller and smaller Component and how to share data 
			   Uni Directional Data flow model


eg:
 Comment <------------------------------> CommentData
   -UserInfo 
	|
	<Logo/Avatar>
        User Name
        <Comment-Test>
        <Comment-Data>


import React from "react";
import ReactDOM from "react-dom/client";

function formateDate(date) {
    return date.toLocaleDateString()

}

//without breaking 
const Comment = props => {
    return <div className="comment">
        <div className="userinfo">
            {/* Segment -1 */}
            <div className="avatar">
                <img src={props.author.avatarUrl} alt="Author Name" />
            </div>
            {/* Segment 2 */}
            <div className="username">
                <p>{props.author.name}</p>
            </div>
            {/* Segment 3 */}
            <div className="commenttext">
                <p>{props.text}</p>
            </div>
            {/* Segment 4 */}
            <div className="commentdate">
                {formateDate(props.date)}
            </div>
        </div>
    </div>
}

const App = () => {
    //pass data to the comments:this data may come from api later 
    const comment = {
        date: new Date(),
        text: 'React is awesome lib',
        author: {
            name: 'Subramanian',
            avatarUrl: 'http://placekitten.com/g/64/64'
        }
    }

    return <>
        <Comment date={comment.date} text={comment.text} author={comment.author} />
    </>
}

const rootElement = ReactDOM.createRoot(document.getElementById('root'))

rootElement.render(<App />)
...................................................................................

How to extract Components?
Avatar
UserInfo

import React from "react";
import ReactDOM from "react-dom/client";

function formateDate(date) {
    return date.toLocaleDateString()

}
export const Avatar = props => {
    return <div className="avatar">
        <img src={props.avatarUrl} alt="Author Name" />
    </div>
}
export const User = props => {
    return <div>
        <p>{props.name}</p>
    </div>
}

export const UserInfo = props => {
    return <div className="userinfo">
        <Avatar avatarUrl={props.author.avatarUrl} />
        <User name={props.author.name} />
    </div>
}
export const CommentDetails = props => {
    return <div>
        <div className="commenttext">
            <p>{props.text}</p>
        </div>
        <div className="commentdate">
            {formateDate(props.date)}
        </div>
    </div>
}
//with breaking 
export const Comment = props => {
    return <div className="comment">
        <div className="userinfo">
            <UserInfo author={props.author} />
        </div>
        <div>
            <CommentDetails text={props.text} date={props.date} />
        </div>
    </div>
}


export const App = () => {
    //pass data to the comments:this data may come from api later 
    const comment = {
        date: new Date(),
        text: 'React is awesome lib',
        author: {
            name: 'Subramanian',
            avatarUrl: 'http://placekitten.com/g/64/64'
        }
    }

    return <>
        <Comment date={comment.date} text={comment.text} author={comment.author} />
    </>
}

const rootElement = ReactDOM.createRoot(document.getElementById('root'))

rootElement.render(<App />)
....................................................................................

Property Rethrow:
import React from "react";
import ReactDOM from "react-dom/client";

//master compoent 
const ProfileMaster = props => <div>
    {/*passing the entire properties to child compoent  */}
    {/* <ProfileDetails id={props.id} name={props.name} status={props.status} address={props.address} /> */}
    {/* Property rethrow: you dont need to pass each and every property manually */}
    <ProfileDetails {...props} title="Profile Details" />
</div>

//details component
const ProfileDetails = props => <div>
    <h1>{props.title}</h1>
    <h1>Id : {props.id}</h1>
    <p>Name : {props.name}</p>
    <p>Status : {props.status ? "Available" : "Not Available"}</p>
    <p>Address</p>
    <address>
        <p>{props.address.street}</p>
        <p>{props.address.city}</p>
        <p>{props.address.state}</p>
    </address>
</div>

export const App = () => {
    const address = {
        street: '10th street',
        city: 'Coimbatore',
        state: 'Tamil Nadu'
    }
    return <ProfileMaster id={1} name="Subramanian" status={true} address={address} />
}

const rootElement = ReactDOM.createRoot(document.getElementById('root'))

rootElement.render(<App />)
....................................................................................
....................................................................................
				Event Handling
....................................................................................

Handling events with React elements is very similar to handling events on DOM elements.

Event Listeners:
  are functions/methods are get Executed when something happens on ui element
like click,touch,tap,press..

How to attach event listeners in react?
 React events are named using camelCase , rather than lowercase.

HTML and Js event handlings

<button onclick="save"/>

React syntax

<button onClick={methodName}/>

import React from "react";
import ReactDOM from "react-dom/client";

const style = {
    textAlign: 'center',
}
//state 
class Rating extends React.Component {
    //state declaration
    state = {
        rating: 0
    }
    //listener
    onRate = () => {
        console.log('onRate')
    }

    render() {
        console.log(this.state)
        return <div >
            <h1 style={style}>Rating App</h1>
            <div>
                <h2>Rating : {this.state.rating}</h2>
                <button onClick={this.onRate} >+</button>
            </div>
        </div>
    }
}

const App = () => {
    return <>
        <Rating />
    </>
}

const rootElement = ReactDOM.createRoot(document.getElementById('root'))

rootElement.render(<App />)
.....................................................................................
			  Functional Programming principles
.....................................................................................
                              Pure Functions


Rule A:
  If function receives input, the function returns the same input without any mutation.

//pure functions

//Rule:A
//If function receives input, the function returns the same input without any mutation.

//impure function
// function displayProfile(profile) {
//     profile.city = 'Delhi'
//     return profile
// }
//pure function
function displayProfile(profile) {
    //profile.city = 'Delhi'
    return profile
}
let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Coimbatore'
}
displayProfile(profile)

import React from 'react';
import ReactDOM from 'react-dom/client';

//Every component is pure function, props are read only 
const Profile = props => {
    //props.city = 'Delhi' 
    return <div>
        <p>{props.id}</p>
        <p>{props.name}</p>
        <p>{props.city}</p>

    </div>
}
const App = () => {
    const profile = {
        id: 1,
        name: 'Subramanian',
        city: 'Coimbatore'

    }
    return <Profile id={profile.id} name={profile.name} city={profile.city} />
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

Rule B:

Rule B:

 What if function receives input, need to be mutated but it should follow the pure function rule.

With help of "Immutablity"

What is immutable?

creating new object every time when you update the object , immutablity.

if the function does that , that function is called pure function.

pure function must return, "immutable object".


//impure function :it does not return immutable object 
// function updateProfile(profile,city) {
//     profile.city = city 
//     return profile ;
// }

//return new object after modifiication/mutation

//way -1 : create new object and copy the all the properties and update the property which you want to modify
// function updateProfile(profile, city) {
//     return {
//         id: profile.id,
//         name: profile.name,
//         city: city
//     }
// }

//way 2 : clone api 
// function updateProfile(profile, city) {
//     return Object.assign({}, profile, { city: city })
// }
//way 3: using spread operator(...)
function updateProfile(profile, city) {
    return { ...profile, city: city }
}
let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Delhi'
}
console.log('before update', profile)
let result = updateProfile(profile, 'Coimbatore')
console.log('after update', result)
//Test whether function is pure or not: the function returns the same object or different object.
console.log('same profile ', profile === result ? 'same' : 'different')

..................................................................................
				Arrays and immutablity
...................................................................................



//impure function :it does not return immutable object 
// function updateProfile(profile,city) {
//     profile.city = city 
//     return profile ;
// }

//return new object after modifiication/mutation

//way -1 : create new object and copy the all the properties and update the property which you want to modify
// function updateProfile(profile, city) {
//     return {
//         id: profile.id,
//         name: profile.name,
//         city: city
//     }
// }

//way 2 : clone api 
// function updateProfile(profile, city) {
//     return Object.assign({}, profile, { city: city })
// }
//way 3: using spread operator(...)
function updateProfile(profile, city) {
    return { ...profile, city: city }
}
let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Delhi'
}
console.log('before update', profile)
let result = updateProfile(profile, 'Coimbatore')
console.log('after update', result)
//Test whether function is pure or not: the function returns the same object or different object.
console.log('same profile ', profile === result ? 'same' : 'different')
/////////////////////////////////////////////////////////////////////////////////////
                   //Arrays and immutablity

//impure function
//array push method modifies existing array memory address
//push is mutable api : dont use
// function addTodo(todos, todo) {
//     return todos.push(todo) // modifies the existing array.
// }    
// //pure function
// function addTodo(todos, todo) {
//     return todos.concat(todo) //returns new array after add
// }
function addTodo(todos, todo) {
    return [...todos,todo] //returns new array after add
}
let todos = [{
    title: 'Learn react',
    done: true
}];
Object.freeze(todos)
let addedTodos = addTodo(todos, { title: 'Learn Pure functions', done: false })
console.log(addedTodos)


Array Pure functions api

1.concat - add
2.map - iterations
3.filter - iterations with filtering
4.reduce - iterations with filtering


import React from "react";
import ReactDOM from "react-dom/client";

class Counter extends React.Component {
    //component's data is encapsulated inside state variable
    state = {
        //data 
        counter: 0 // inital state /Current State
    }
    //event listener
    onIncrement = () => {
        // console.log('onIncrement')
        // this.setState((prvState) => {
        //     //return immutable object(immutable state)
        //     return {
        //         counter: prvState.counter + 1
        //     }
        // })
        this.setState((prvState) => {
            //return Object.assign({}, prvState, { counter: prvState.counter + 1 })
            return { ...prvState, counter: prvState.counter + 1 }
        })
    }

    render() {
        console.log(this.state)
        return <div>
            <h1>Counter App</h1>
            <h2>Counter Value {this.state.counter}</h2>
            <button onClick={this.onIncrement}>+</button>
        </div>
    }
}

const App = () => <div>
    <Counter />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     
....................................................................................
			Component Responsiablity
....................................................................................

The component may have state+biz+ui

if the component having state and biz logic, should not have ui logic, you have to pass state as prop to another component.

Parent - Child
 state  --prop

State as prop -  dynamic props.
.....................................................................................
import React from "react";
import ReactDOM from "react-dom/client";

class Counter extends React.Component {
    state = {
        //data 
        counter: 10 // inital state /Current State
    }
    //event listener
    onIncrement = () => {
        this.setState((prvState) => {
            return { ...prvState, counter: prvState.counter + 1 }
        })
    }

    render() {
        return <CounterDashBoard counter={this.state.counter} onIncrement={this.onIncrement} />
    }
}

//child component
export const CounterDashBoard = props => {
    return <div>
        <h1>Counter App</h1>
        <h2>Counter Value {props.counter}</h2>
        <button onClick={props.onIncrement}>+</button>
    </div>
}

const App = () => <div>
    <Counter />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     
.....................................................................................
			More state variables

import React from "react";
import ReactDOM from "react-dom/client";

class Comment extends React.Component {
    state = {
        like: 0,
        dislike: 0,
        nutral: 0
    }
    //event listener
    onLike = () => {
        this.setState(prvState => {
            return {
                like: prvState.like + 1,
                dislike: prvState.dislike,
                nutral: prvState.nutral
            }
        })
    }
    onDisLike = () => {
        this.setState(prvState => {
            return {
                like: prvState.like,
                dislike: prvState.dislike + 1,
                nutral: prvState.nutral
            }
        })
    }
    onNutural = () => {
        this.setState(prvState => {
            return {
                like: prvState.like,
                dislike: prvState.dislike,
                nutral: prvState.nutral + 1
            }
        })
    }

    render() {

        console.log('Current State=>', this.state)
        // return <CommentDashBoard like={this.state.like} dislike={this.state.dislike} nutral={this.state.nutral} onLike={this.onLike} onDisLike={this.onDisLike} onNutural={this.onNutural} />
        return <CommentDashBoard {...this.state} onLike={this.onLike} onDisLike={this.onDisLike} onNutural={this.onNutural} />
    }
}

//child component
export const CommentDashBoard = props => {
    return <div>
        <h1>Comment App</h1>
        <h2>Like {props.like} Dislike {props.dislike} Nutral {props.nutral}</h2>
        <button onClick={props.onLike}>Like</button>
        <button onClick={props.onDisLike}>DisLike</button>
        <button onClick={props.onNutural}>Nutral</button>

    </div>
}

const App = () => <div>
    <Comment />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     
...................................................................................
				List Rendering
import React from "react";
import ReactDOM from "react-dom/client";
import { TODOS } from "./mock-data/todos";

// const TodoList = props => {
//     return <div>
//         <ul>
//             {
//                 props.todos.map(todo => {
//                     return <TodoDetails key={todo.id} title={todo.title} />
//                 })
//             }
//         </ul>
//     </div>
// }

const TodoList = props => {
    return <div>
        <ul>
            {
                props.todos.map(todo => <TodoDetails key={todo.id} title={todo.title} />)
            }
        </ul>
    </div>
}
const TodoDetails = ({ title }) => <li>{title}</li>

const App = () => <div>
    <TodoList todos={TODOS} />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     
.....................................................................................
			  Component Life cycle
....................................................................................
https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/		

Component Life cycles has three phases

1.mount - inital phase
 constructor
 render - creating v dom / v dom tree
 componentDidMount

2.update

3.unmount



render===>vdom==>fed into target==>componentDidMount

what is role of render?
  Just prepare fresh vdom

What is role componentDidMount?
  any resource intensive tasks

1.timers - any async operations
2.ajax -api calls 
3.websocket calls
4.rxjs subscriptions

..........

eg:
import React, { Component } from "react";
import ReactDOM from "react-dom/client";

class Parent extends Component {
    constructor() {
        super() // calling super class constructor
        console.log('Parent Constructor is called')
    }
    render() {
        console.log('Parent render is called')

        return <div>
                <Child/>
        </div>
    }
    componentDidMount() {
        console.log('Parent did Mount is called')
    }
}


class Child extends Component {
    constructor() {
        super() // calling super class constructor
        console.log('Child Constructor is called')
    }
    render() {
        console.log('Child render is called')

        return <div>

        </div>
    }
    componentDidMount() {
        console.log('Child did Mount is called')
    }
}

const App = () => <div>
    <Parent/>
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     
....................................................................................
			Web service Integration
....................................................................................

ajax apis:
React has no separate ajax apis.

react says you can use any third party ajax libs

1.fetch
2.axios
3.jquery ajax
etc..any ajax...

fetch:
https://developers.google.com/web/shows/google-io/2015/fetch

fetch features:
1.browser native
2.fetch is promise powered

Async:
callbacks
promise with thenables
promise with async await


import React, { Component } from "react";
import ReactDOM from "react-dom/client";

//error Component
const ErrorMessage = props => <div>
    {props.error}
</div>
const Spinner = props => <div>
    <h2>Loading....</h2>
</div>


class Todos extends Component {
    //state to hold data
    state = {
        error: null, // error 
        isLoaded: false, // spinner/loader
        todos: [] // data
    }
    render() {
        //Conditional rendering:based on ui state we need to show component
        const { error, isLoaded, todos } = this.state;
        if (error) {
            return <ErrorMessage error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
            return <div>
                {
                    todos.map(todo => <div key={todo.id}>
                        <span>{todo.title}</span>
                    </div>)
                }
            </div>
        }
    }
    componentDidMount() {
        //api call to fetch data from the end point 
        // setTimeout(() => {
        //     const url = 'https://jsonplaceholder.typicode.com/todos'
        //     fetch(url)
        //         .then(response => response.json())
        //         .then(todos => {
        //             this.setState(previousState => {
        //                 return {
        //                     ...previousState,
        //                     todos: previousState.todos.concat(todos),
        //                     isLoaded: true
        //                 };
        //             });

        //         }).catch(err => {
        //             console.log(err)
        //         })
        // }, 5000)

        const url = 'https://jsonplaceholder.typicode.com/todos'
        fetch(url)
            .then(response => response.json())
            .then(todos => {
                this.setState(previousState => {
                    return {
                        ...previousState,
                        todos: previousState.todos.concat(todos),
                        isLoaded: true
                    };
                });

            }).catch(err => {
                console.log(err)
            })
    
}
}




const App = () => <div>
    <Todos />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)   

.....................................................................................
Short cut : using async..await..

import React, { Component } from "react";
import ReactDOM from "react-dom/client";

//error Component
const ErrorMessage = props => <div>
    {props.error}
</div>
const Spinner = props => <div>
    <h2>Loading....</h2>
</div>

class Todos extends Component {
    //state to hold data
    state = {
        error: null, // error 
        isLoaded: false, // spinner/loader
        todos: [] // data
    }
    render() {
        //Conditional rendering:based on ui state we need to show component
        const { error, isLoaded, todos } = this.state;
        // Task for you : to organize this ui into separate components
        if (error) {
            return <ErrorMessage error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
            return <div>
                {
                    todos.map(todo => <div key={todo.id}>
                        <span>{todo.title}</span>
                    </div>)
                }
            </div>
        }
    }
    async componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        try {
            const todos = await (await fetch(url)).json()
            this.setState({
                todos: todos,
                isLoaded: true
            })
        } catch (error) {
            this.setState({
                isLoaded: true,
                error
            });
        }

    }
}




const App = () => <div>
    <Todos />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)   
..................................................................................					Update Phase

It is called once user starts interaction.

Update cycle triggers because of three things



1.new Props => dynamic props
2.setState  => when ever you mutate the state.
3.forceUpdate => when you want render ui because of some other activites

methods:
 render
 componentDidUpdate
   ->similar to componentDidMount only

 if you want to fetch data from the api after clicking some thing
import React, { Component } from "react";
import ReactDOM from "react-dom/client";

class Parent extends Component {

    state = {
        counter: 0
    }
    constructor() {
        super() // calling super class constructor
        console.log('Parent Constructor is called')
    }
    render() {
        console.log('Parent render is called')

        return <div>
            <h1>{this.state.counter}</h1>
            <Child />
            <button onClick={() => {
                this.setState({ counter: this.state.counter + 1 })
            }}>+</button>
        </div>
    }
    componentDidMount() {
        console.log('Parent did Mount is called')
    }
    componentDidUpdate() {
        console.log('Parent did update is called')

    }
}


class Child extends Component {
    constructor() {
        super() // calling super class constructor
        console.log('Child Constructor is called')
    }
    render() {
        console.log('Child render is called')
        return <div>

        </div>
    }
    componentDidMount() {
        console.log('Child did Mount is called')
    }
    componentDidUpdate() {
        console.log('Child did update is called')

    }
}

const App = () => <div>
    <Parent />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)     

......................................................................................

Conditional Rendering with Selected Item:
import React, { Component } from "react";
import ReactDOM from "react-dom/client";

//error Component
const ErrorMessage = props => <div>
    {props.error}
</div>
const Spinner = props => <div>
    <h2>Loading....</h2>
</div>

const style = {
    cursor: 'pointer'
}
class Todos extends Component {
    //state to hold data
    state = {
        error: null, // error 
        isLoaded: false, // spinner/loader
        todos: [], // data
        todo: null
    }
    onSelected = async (id) => {
        const url = `https://jsonplaceholder.typicode.com/todos/${id}`
        try {
            const todo = await (await fetch(url)).json() // 
            this.setState({
                todo: todo,
            })
            console.log(todo)
        } catch (error) {
            this.setState({
                isLoaded: true,
                error
            });
        }
    }

    render() {
        //Conditional rendering:based on ui state we need to show component
        const { error, isLoaded, todos, todo } = this.state;
        // Task for you : to organize this ui into separate components
        if (error) {
            return <ErrorMessage error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
            return <div style={{ marginLeft: 150 }}>
                <div style={{ backgroundColor: 'yellow' }}>
                    {todo ? <>
                        <h1>Todo Details</h1>
                        <p>id: {todo.id}</p>
                        <p>title: {todo.title}</p>
                        <p>Status: {todo.completed ? 'Completed' : 'Not Completed'}</p>
                    </> : ''}
                </div>
                <hr />
                {
                    todos.map(todo => <div key={todo.id}>
                        <span onClick={() => {
                            this.onSelected(todo.id)
                        }} style={style}>{todo.title}</span>
                        <hr />
                    </div>)
                }
            </div>
        }
    }
    async componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        try {
            const todos = await (await fetch(url)).json()
            this.setState({
                todos: todos,
                isLoaded: true
            })
        } catch (error) {
            this.setState({
                isLoaded: true,
                error
            });
        }

    }
}



const App = () => <div>
    <Todos />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)  
.....................................................................................
				Forms
....................................................................................
				EventTarget
How to get User input?


import React, { Component } from "react";
import ReactDOM from "react-dom/client";

class UserInput extends Component {
    state = {
        firstName: ''
    }
    // handleChange = evt => {
    //     //Get Text Box Reference
    //     const target = evt.target
    //     console.log(target.value)
    //     this.setState({
    //         text: evt.target.value
    //     })
    // }
    render() {
        return <div style={{ margin: 50 }}>
            <h1>{this.state.text}</h1>
            <div>
                {/* <input onChange={this.handleChange} /> */}
                {/* on+EventName=> onBlur onUpdate onLeave */}
                <input onChange={(evt) => {
                    const target = evt.target
                    console.log(target.value)
                    this.setState({
                        firstName: evt.target.value
                    })
                }} />
            </div>
            <button onClick={() => {

            }}>Save</button>
        </div>
    }

}



const App = () => <div>
    <UserInput />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)  
...................................................................................
			 Fragements
...................................................................................

JSX Basic rules:

1.Every element must have been closed
const Greeter = props=>{
    return <div>
        {/* element is closed */}
        <h1>hello</h1>
        {/* jsx:comments self closing */}
        <img />
    </div>
}


2.We cant have silbings directly without root element.

const Hello = props => {
    return <p>Hello</p>
          <p>Hai</p>
   
}

compile time error ; no parent containter element.

what if i dont want container element like div,span,header,footer...

In React 16 onwards, react introduced a concept fragments:
   avoid compil time errors

import React  from "react";
import ReactDOM from "react-dom/client";

const Greeter = props => {
    return <div>
        {/* element is closed */}
        <h1>hello</h1>
        {/* jsx:comments self closing */}
        <img />
    </div>
}

// const Hello = props => {
//     return <React.Fragment>
//         <p>Hello</p>
//         <p>Hai</p>
//     </React.Fragment>
// }

// const Hello = props => {
//     return <Fragment>
//         <p>Hello</p>
//         <p>Hai</p>
//     </Fragment>
// }

const Hello = props => {
    return <>
        <p>Hello</p>
        <p>Hai</p>
    </>
}
const App = () => <div>
    <Hello />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)  

eg:
import React  from "react";
import ReactDOM from "react-dom/client";

const Greeter = props => {
    return <div>
        {/* element is closed */}
        <h1>hello</h1>
        {/* jsx:comments self closing */}
        <img />
    </div>
}

// const Hello = props => {
//     return <React.Fragment>
//         <p>Hello</p>
//         <p>Hai</p>
//     </React.Fragment>
// }

// const Hello = props => {
//     return <Fragment>
//         <p>Hello</p>
//         <p>Hai</p>
//     </Fragment>
// }

const Hello = props => {
    return <>
        <p>Hello</p>
        <p>Hai</p>
    </>
}
const App = () => <>
    <Hello />
</>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)  
....................................................................................
				Component as Prop
....................................................................................

const Link=()=><ul></ul>

const Header=()=><header>
   <Link/>
</header>
const Page = ()=><Header/>
const App = ()=><Page/>

<Page>
   <Header>
	<Logo></Logo>
	<Link>
	    <MenuBar></MenuBar>
        </Link>
   </Header>
</Page>

import React from "react";
import ReactDOM from "react-dom/client";


const Link = props => {
    return <>
        {props.children}
    </>
}

const Header = props => {
    return <>
        <h1>{props.title}</h1>
        {props.children}
    </>
}
const Footer = props => {
    return <h1>Footer</h1>
}

const Page = props => <>
    {props.children}
</>

const MenuItems = props => <ul>
    <li><a href="#">profile</a></li>
    <li><a href="#">services</a></li>
    <li><a href="#">success stories</a></li>
</ul>


const MenuItems = props => <ul>
     {props.datasource.map(item=>{
       <li><a href=`${item}`>{item}</a></li>
  })}
</ul>

const App = () => <div>
    <Page>
        {/* here Header Component passed as prop */}
        <Header title="Customer Management">
         <hr/>
            <Link>
                <MenuItems datasource={['profile','services','successstores']} />
            </Link>
        </Header>
        <Footer>

        </Footer>
    </Page>
</div>


const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)  
...................................................................................
			     Hooks
..................................................................................

What is hook?
 It is a new feature introduced in react 16.
 Simple abstraction for class compoents-  how to remove classes from react.

Intention is functional component for every things.

objective of hooks:

1.to eleminate class components as much possible.
2.Resuable application behaviours
   eg:ajax calls


Hook is just simple javascript function.
which may take arg or may not.
Which may or may not return something 	


every hook function starts with
  "use"+functionName ==>hook Syntax

eg:
"useState"
"useContext"
"useEffect"
"useAjax"
"useWebSocket"
"useLayout"
etc....
you can create your own hooks as well.

import React, { useState } from "react";
import ReactDOM from "react-dom/client";

class Counter__ extends React.Component {
    //component's data is encapsulated inside state variable
    state = {
        //data 
        counter: 0 // inital state /Current State
    }
    //event listener
    onIncrement = () => {

        this.setState((prvState) => {
            //return Object.assign({}, prvState, { counter: prvState.counter + 1 })
            return { ...prvState, counter: prvState.counter + 1 }
        })
    }

    render() {
        console.log(this.state)
        return <div>
            <h1>Counter App</h1>
            <h2>Counter Value {this.state.counter}</h2>
            <button onClick={this.onIncrement}>+</button>
        </div>
    }
}

//Functional Component using hooks:
const Counter = props => {
    //state declaration
    const [count, setCount] = useState(0)
    const onIncrement = () => {
        // setCount(count => {
        //     return count + 1
        // })
        setCount(count + 1)
    }

    return <div>
        <h1>Counter App</h1>
        <h2>Value : {count}</h2>
        <button onClick={onIncrement}>+</button>
    </div>
}


const App = () => <div>
    <Counter />
</div>
const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />) 
.....................................................................................
			Multi state Hook
.....................................................................................

import React, { useState } from "react";
import ReactDOM from "react-dom/client";


const Counter = props => {
    //state declaration => state = {inc:0,dec:100}
    const [inc, setInc] = useState(0)
    const [dec, setDec] = useState(100)
    //listener
    const onIncrement = () => {
        setInc(inc + 1)
    }
    const onIncrementByValue = (value) => {
        setInc(inc + value)
    }
    return <div>
        <h1>Counter App</h1>
        <h2>Increment: {inc} Decrement {dec}</h2>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => setDec(dec - 1)}>-</button>
        <button onClick={() => onIncrementByValue(2)}>DoubleIt</button>

    </div>
}


const App = () => <div>
    <Counter />
</div>
const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />) 
..................................................................................
			 Object inside Hook

import React, { useState } from "react";
import ReactDOM from "react-dom/client";


const Counter = props => {
    //state = { counter:{ inc:0,dec:0} }
    const [counter, setCounter] = useState({ inc: 0, dec: 100 })

    const onIncrement = () => {
        //
        // setCounter(counter => {
        //     return { ...counter, inc: counter.inc + 1 }
        // })
        // setCounter(counter =>({ ...counter, inc: counter.inc + 1 }))
        setCounter(({ ...counter, inc: counter.inc + 1 }))

    }

    return <div>
        <h1>Counter App</h1>
        <h2>Increment: {counter.inc} Decrement {counter.dec}</h2>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => setCounter(({ ...counter, dec: counter.dec - 1 }))
        }>-</button>


    </div>
}


const App = () => <div>
    <Counter />
</div>
const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />) 
.....................................................................................
			 Component Life Methods and Hooks
...................................................................................
import React, { Component, useEffect, useState } from "react";
import ReactDOM from "react-dom/client";

//error Component
const ErrorMessage = props => <div>
    {props.error}
</div>
const Spinner = props => <div>
    <h2>Loading....</h2>
</div>


class Todos__ extends Component {
    //state to hold data
    state = {
        error: null, // error 
        isLoaded: false, // spinner/loader
        todos: [] // data
    }
    render() {
        //Conditional rendering:based on ui state we need to show component
        const { error, isLoaded, todos } = this.state;
        if (error) {
            return <ErrorMessage error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
            return <div>
                {
                    todos.map(todo => <div key={todo.id}>
                        <span>{todo.title}</span>
                    </div>)
                }
            </div>
        }
    }
    componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        fetch(url)
            .then(response => response.json())
            .then(todos => {
                this.setState(previousState => {
                    return {
                        ...previousState,
                        todos: previousState.todos.concat(todos),
                        isLoaded: true
                    };
                });

            }).catch(err => {
                console.log(err)
            })

    }
}
///////////////////////////////////////////////////////////////////////////////////

const Todos = props => {
    const [items, setItems] = useState({
        error: null, // error 
        isLoaded: false, // spinner/loader
        todos: [] // data
    })
    //componentDidMount
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        fetch(url)
            .then(response => response.json())
            .then(todos => {
                //Change this code in simple way
                setItems(previousState => {
                    return {
                        ...previousState,
                        todos: previousState.todos.concat(todos),
                        isLoaded: true
                    };
                });

            }).catch(err => {
                console.log(err)
            })

    }, [])

    const { error, isLoaded, todos } = items;
    if (error) {
        return <ErrorMessage error={error} />
    } else if (!isLoaded) {
        return <Spinner />
    } else {
        return <div>
            {
                todos.map(todo => <div key={todo.id}>
                    <span>{todo.title}</span>
                </div>)
            }
        </div>
    }
}




const App = () => <div>
    <Todos />
</div>

const rootElement = ReactDOM.createRoot(document.getElementById('root'))
rootElement.render(<App />)   
...................................................................................

Tasks:
1.Code Refactoring
 =>Convert thenables into async..await
2.Select an item and show the item - using Hooks

3.Create User Registeration Form
    First Name
    last Name
    city -  select
    Education - multi chechebox
    Gender -  radio button
  Submit - when you submit you have collect complete user information and show in the console.
.....................................................................................	  			     Redux -State Management
....................................................................................

What is Redux?

  Redux is a pattern and lib for managining and updating application state, using event driven programming model.

state : data
In General state is encaspulated inside component, when ever we change /mutate the data , based on mutation we re render ui and update the ui based on "pure functions and immuability pattern".


Why Redux? what is the problem of  encapsulating state inside component


->if application has large amounts of state(data) , that are needed in many places in the app.
->The app state is updated frequently over period of time.
->The update logic is very complex.
->If app is developed by many developer.

Note: 
 Not all apps need redux.

Redux tools:

1.redux.js
  simple standalone javascript lib. redux core.

2.react-redux
  it is binding lib for connecting redux with react.

3.redux toolkit
   It is wrapper lib for old redux

4.Redux dev tool
  To inspect history of app state changes- time travel debugging.

Core Concepts:

if you look at the simple component

import { useState } from "react"

const Counter = props => {
    //state: a counter
    const [counter, setCounter] = useState(0)

    //Action: code that causes an update to the state when something happens(cick button)
    const increment = evt => {
        setCounter(counter + 1);
    }

    //view: UI Definition
    return <div>
        Value : {counter} <button onClick={increment}>+</button>
    </div>
}

This app contains

1.state - Source of truth that drives application.
2.The view - The declarative description of the UI based on current state
3.The actions -The events that occur in the app based on user input,and trigger updates in the state.


Patterns:

1.immmutablity
  - immutablity pattern helps to avoid state corruption when many components tries to update.

2.Actions
  Action is  request for redux to change the state 
  Action is a plain javascript object( {}) that has a type field.
  {type:''}
  You can think of an action as an event that describes something that happened in the   application.
 
syntax:

  const actionName= { 
    type:'domainname/eventname'    
  } 

  const increment= { 
    type:'stock/increment'    
  } 

with payload : input

  const increment= { 
    type:'stock/increment',
    payload: 'new Product'   
  }

2.2.Action Creators
  Actions are requests.
 Where as action creators are request creators -  function which returns action

 function incrementStock(payload){
    return { 
    type:'stock/increment',
    payload: payload   
  }
 }

incrementStock('new Product');
 

3.Reducers

->A reducer function , that receives the request and process the request and returns response
  -having biz logic
->A reducer is pure function, should return always immutable datastructure(state)
->You can think of reducer is like event listener which handles events based on event(action) type.

Reducer has some basic rules

1. reducer must take two args
   -first arg initalstate, second arg is action(event => name of the event + payload).

   function stockReducer(state=initState,action){
   
    
   }
2.reducer function must have body for event filtering and should return new state based on immutable logic


   function stockReducer(state=initState,action){
      switch(action.type){
	case 'stock/increment':
		return {...} //immutable ds
	default
	   return state;
     }
    
   }

3.store
 Where the current redux application lives in an object called store.

 Store is simple javascript object.

Store contains two things

-storage for application state - {}

-apis for sending request,processing biz logic,sending response.....


Store apis:

1.Dispatch - store.dispatch()

The only way to update the state is to call store.dispatch method by passing action object as parameter.

 store.dispatch(action)----------->store

As soon as the store receives the request, it will run/call/invoke the reducer function

 store.dispatch(action)----------->store----run the reducer function

As soon as the reducer gets called, it verifies the type of action it has come, computes the new state.

 store.dispatch(action)----------->store----run the reducer function---return new State

The reducer returns new state to the Store only--the previous state will be updated with new modified data.


 store.dispatch(action)----------->store----run the reducer function---return new State --store.

The store as soon recieves new state, it will run a listener "subcribe", where you can collect all the new state.

From the listener, state can be given to UI-View

 store.dispatch(action)----------->store----run the reducer function---return new State --store----subscribe-------VIEW.


4.Selectors

   Selector is function that know how to extract specific pieces of information from a store state value.

 const value = select(store.getState())


...

store.subscribe(callback)
   response listener


store.getState()
   To read the entire app state.
.....................................................................................
			   Redux project setup
.....................................................................................

Incase old react project:

 npm install redux react-redux  

in case new project

 npx create-react-app myapp  --template redux


appState={
  r: {}
}


import React from 'react';
import { configureStore } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
/////////////////////////////////////////////////////////////////////////////////////
//Redux
//1.reducer
// state= The reducer state- inital state
// action => the Request object {type:'counter/nameoftheaction'}
const CounterReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            //immutable logic 
            return { ...state, counter: state.counter + 1 }
        case 'counter/decrement':
            //immutable logic 
            return { ...state, counter: state.counter - 1 }
        default:
            return state; //default state//initali state would be render during inital render
    }
}
//create Store object .
const appStore = configureStore({
    reducer: {
        counterReducer: CounterReducer
    }
})

//React

const Counter = props => {
    //useSelect will filter state based on reducer
    //appState.reducer.state
    const counter = useSelector(appState => {
        console.log(appState.counterReducer)
        return appState.counterReducer.counter
    })
    //Get the Dispatcher
    const dispatch = useDispatch()

    const onIncrement = evt => {
        //trigger reducer biz logic
        const incrementAction = {
            type: 'counter/increment'
        }
        dispatch(incrementAction)
    }

    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: 'counter/decrement' })
        }}>-</button>
    </div>

}


/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Counter />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
...................................................................................
			 Code Structure


src/features/counter

counter.reducer.js

const CounterReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            //immutable logic 
            return { ...state, counter: state.counter + 1 }
        case 'counter/decrement':
            //immutable logic 
            return { ...state, counter: state.counter - 1 }
        default:
            return state; //default state//initali state would be render during inital render
    }
}
export { CounterReducer }

counter.jsx
import { useSelector, useDispatch } from 'react-redux';

const Counter = props => {
    //useSelect will filter state based on reducer
    //appState.reducer.state
    const counter = useSelector(appState => {
        console.log(appState.counterReducer)
        return appState.counterReducer.counter
    })
    //Get the Dispatcher
    const dispatch = useDispatch()

    const onIncrement = evt => {
        //trigger reducer biz logic
        const incrementAction = {
            type: 'counter/increment'
        }
        dispatch(incrementAction)
    }

    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: 'counter/decrement' })
        }}>-</button>
    </div>

}
export { Counter }


src/app/store.js
import { configureStore } from '@reduxjs/toolkit';
import { CounterReducer } from '../features/counter/counter.reducer';

export const appStore = configureStore({
    reducer: {
        counterReducer: CounterReducer
    }
})

src/index.js
import React from 'react';
import { createRoot } from 'react-dom/client';
import { Provider } from 'react-redux';
import { appStore } from './app/store'
import { Counter } from './features/counter/counter';

/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Counter />
    </Provider>
</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
.................................................................................
			  Actions

actions names should not be hard coded
src/features/counter/counter.actions.js
export const incrementAction = 'counter/increment'
export const decrementAction = 'counter/decrement'

Useage

import { incrementAction, decrementAction } from "./counter.actions";

const CounterReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case incrementAction:
            //immutable logic 
            return { ...state, counter: state.counter + 1 }
        case decrementAction:
            //immutable logic 
            return { ...state, counter: state.counter - 1 }
        default:
            return state; //default state//initali state would be render during inital render
    }
}
export { CounterReducer }

...................................................................................
			How to send Input to the Reducer -payload
...................................................................................

src/features/counter/counter.actions.js
export const incrementByAmount = 'counter/incrementByAmount'

counter.reducer.js
import { incrementAction, decrementAction, incrementByAmount } from "./counter.actions";


const CounterReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case incrementAction:
            //immutable logic 
            return { ...state, counter: state.counter + 1 }
        case decrementAction:
            //immutable logic 
            return { ...state, counter: state.counter - 1 }
        case incrementByAmount:
            //immutable logic 
            return { ...state, counter: state.counter + action.payload }
        default:
            return state; //default state//initali state would be render during inital render
    }
}
export { CounterReducer }

counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { decrementAction, incrementAction, incrementByAmount } from "./counter.actions";

const Counter = props => {
    //useSelect will filter state based on reducer
    //appState.reducer.state
    const counter = useSelector(appState => {
        console.log(appState.counterReducer)
        return appState.counterReducer.counter
    })
    //Get the Dispatcher
    const dispatch = useDispatch()

    const onIncrement = evt => {
        dispatch({ type: incrementAction })
    }

    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: decrementAction })
        }}>-</button>

        <button onClick={() => {
            dispatch({ type: incrementByAmount, payload: 2 })
        }}>IncrementBy2</button>
    </div>

}
export { Counter }

.....................................................................................				 Breaking the Component into Two

Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { CounterDashBoard } from './counterdashboard';

//Higher Order Component
//This Component only Subscribes state as prop and dispatch as Prop 
//and again its as prop to another child  child
const Counter = props => {
    const counter = useSelector(appState => appState.counterReducer.counter)
    return <CounterDashBoard counter={counter} />
}
export { Counter }

CounterDashBoard.jsx
import { decrementAction, incrementAction, incrementByAmount } from "./counter.actions";
import { useDispatch } from 'react-redux';


const CounterDashBoard = props => {
    const dispatch = useDispatch()
    const onIncrement = () => {
        dispatch({ type: incrementAction })
    }
    return <div>
        <h1>Counter {props.counter}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: decrementAction })
        }}>-</button>

        <button onClick={() => {
            dispatch({ type: incrementByAmount, payload: 2 })
        }}>IncrementBy2</button>
    </div>
}
export { CounterDashBoard }
....................................................................................
			 Multi Reducer

please refer code base

.....................................................................................
			 Complex Immutable logic
...................................................................................
Deep Nested Object:

const profile = {
    id: 1,
    name: 'Subramanian',
    address: {
        city: 'coimbatore'
    }
};

const ProfileReducer =(state=profile,action){
   ...
   
  
}

store.dispatch({type:'profile/update',payload:'chennai'})

import React from 'react';
import { configureStore } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
/////////////////////////////////////////////////////////////////////////////////////
const profile = {
    id: 1,
    name: 'Subramanian',
    address: {
        state: 'Tamil Nadu',
        city: 'coimbatore',
        pincode: '6111 111'

    },
    skill: {
        ui: {
            subject: 'react',
            points: 10
        }
    }
};
const ProfileReducer = (state = profile, action) => {
    switch (action.type) {
        case 'profile/update':
            //state.address.city ='Delhi'
            return {
                ...state,
                address: {
                    ...state.address,
                    city: action.payload
                }
            }
        case 'profile/like':

           
            return {
                ...state,                
                skill: {
                    ...state.skill,
                    ui: {
                        ...state.skill.ui,
                        points: state.skill.ui.points + 2
                    }
                }
            }

        default:
            return state;
    }
}
//create Store object .
const appStore = configureStore({
    reducer: {
        profile: ProfileReducer
    }
})

//React

const Profile = props => {

    const profile = useSelector(appState => {
        return appState.profile
    })
    console.log(profile.skill.ui.points)

    //Get the Dispatcher
    const dispatch = useDispatch()


    return <div>
        <h1>Profile Information</h1>
        <div>
            <p>Id {profile.id}</p>
            <p>Name {profile.name}</p>
            <p>City {profile.address.city}</p>
            <h2>Skill</h2>
            <p>Subject {profile.skill.ui.subject}</p>
            <p>Points {profile.skill.ui.points}</p>

        </div>
        <button onClick={() => {
            dispatch({ type: 'profile/update', payload: 'Chennai' })
        }}>UpdateCity</button>
        <button onClick={() => {
            dispatch({ type: 'profile/like' })
        }}>Likes</button>
    </div>

}


/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Profile />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
..................................................................................
		   How to write immutable logic using immer js
...................................................................................

What is immer js?

Immer simplifies handling immutable data structures.


eg:
const baseState = [
    {
        title: "Learn TypeScript",
        done: true
    },
    {
        title: "Try Immer",
        done: false
    }
]

immutable logic for adding new property

  baseState.concat({}) = > newArray with new Item.

import produce from "immer"

return produce(baseState,draft=>{
    draft[1].done = true
    draft.push({title: "Tweet about it"})
})

const nextState = produce(baseState, draft => {
    draft[1].done = true
    draft.push({title: "Tweet about it"})
})


How to start working with immer?

npm install immer

import React from 'react';
import { configureStore } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
import produce from 'immer';
/////////////////////////////////////////////////////////////////////////////////////
const profile = {
    id: 1,
    name: 'Subramanian',
    address: {
        state: 'Tamil Nadu',
        city: 'coimbatore',
        pincode: '6111 111'

    },
    skill: {
        ui: {
            subject: 'react',
            points: 10
        }
    }
};
const ProfileReducer = (state = profile, action) => {
    switch (action.type) {
        case 'profile/update':
            //state.address.city ='Delhi'
            // return {
            //     ...state,
            //     address: {
            //         ...state.address,
            //         city: action.payload
            //     }
            // }
            return produce(state, draft => {
                console.log(draft)
                draft.address.city = action.payload
            })
        case 'profile/like':
            // return {
            //     ...state,
            //     skill: {
            //         ...state.skill,
            //         ui: {
            //             ...state.skill.ui,
            //             points: state.skill.ui.points + 2
            //         }
            //     }
            // }
            return produce(state, draft => {
                draft.skill.ui.points++
            })

        default:
            return state;
    }
}
//create Store object .
const appStore = configureStore({
    reducer: {
        profile: ProfileReducer
    }
})

//React

const Profile = props => {

    const profile = useSelector(appState => {
        return appState.profile
    })
    console.log(profile.skill.ui.points)

    //Get the Dispatcher
    const dispatch = useDispatch()


    return <div>
        <h1>Profile Information</h1>
        <div>
            <p>Id {profile.id}</p>
            <p>Name {profile.name}</p>
            <p>City {profile.address.city}</p>
            <h2>Skill</h2>
            <p>Subject {profile.skill.ui.subject}</p>
            <p>Points {profile.skill.ui.points}</p>

        </div>
        <button onClick={() => {
            dispatch({ type: 'profile/update', payload: 'Chennai' })
        }}>UpdateCity</button>
        <button onClick={() => {
            dispatch({ type: 'profile/like' })
        }}>Likes</button>
    </div>

}


/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Profile />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);

...................................................................................

Shopping Cart:
import React from 'react';
import { configureStore } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
import produce from 'immer';
import "./list.css"
import './index.css';

/////////////////////////////////////////////////////////////////////////////////////

const products = [{
    id: 1,
    name: 'IPhone',
    qty: 10
},
{
    id: 2,
    name: 'Google Pixel',
    qty: 40
}

]
const CartReducer = (state = products, action) => {
    switch (action.type) {
        case 'cart/incrementqty':
            return produce(state, draft => {
                draft[action.payload].qty += 1
            })
        case 'cart/decrementqty':
            return produce(state, draft => {
                if (draft[action.payload].qty > 1) {
                    draft[action.payload].qty -= 1
                }                
            })
        default:
            return state
    }
}
//create Store object .
const appStore = configureStore({
    reducer: {
        cart: CartReducer
    }
})

//React

const Cart = props => {

    const cart = useSelector(appState => {
        return appState.cart
    })

    //Get the Dispatcher
    const dispatch = useDispatch()


    return <div>
        <h1>Cart</h1>
        <table>
            <tr>
                <th>Id</th>
                <th>Name</th>
                <th>Qty</th>
                <th>CartAction</th>
            </tr>
            <tbody>
                {
                    cart.map((product, index) => {
                        return <>
                            <tr>
                                <td>{product.id}</td>
                                <td>{product.name}</td>
                                <td>{product.qty}</td>
                                <td style={{ paddingLeft: 40 }}>
                                    <button onClick={() => {
                                        dispatch({ type: 'cart/incrementqty', payload: index })
                                    }}>+</button>
                                    <button onClick={() => {
                                        dispatch({ type: 'cart/decrementqty', payload: index })
                                    }}>-</button>
                                </td>

                            </tr>
                        </>
                    })
                }
            </tbody>
        </table>

    </div>

}


/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Cart />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);



state productState

productReducer
<tr>
....

const productForm = useState({
  name:'',
  price:0
  
})

submit -> dispatch('product/addProduct',payload:productForm)

<form>
   <input  />
   <input  />
</form>
.....................................................................................
			Redux Time Travel Pluggin -Undo,Redo

I want to track, i want to know the state changes in your app...

How to enable time travel pluggin?

 In old redux, we have to configure manually in order to enable redux dev tool

 const store = createStore(
   reducer, /* preloadedState, */
+  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
 );

in modern redux- redux toolkit it is enabled by default

In configure store:

  configureStore({
    reducer:{rd1:{},rd2:{}},  //coimbineReducer
    middleware:{}, //applyMiddleware
    devtool: true
  })
.....................................................................................
			createAction api
.....................................................................................

Generally actions are hardcoded

 const addProduct = 'product/addProduct' 

createAction method will help to create actions

syntax:
  createAction(type,prepareAction?)

Action creator:

 const INCREMENT = 'counter/increment'

   function increment(payload){
      return {
        type:INCREMENT,
        payload:payload
      }
   }

  const action =  increment(10)
   dispatch(action) //{type:'counter/increment',payload:10}

with creationAction
const increment=  createAction('counter/increment')


const cartincrement = createAction('cart/incrementqty')
const { type } = cartincrement()
//console.log('cart',cartincrement())
..................................................................................
			 Refactoring Reducers

createReducer:
  It is utility function that simplifies redux reducer functions.

Old Reducer:

const CartReducer = (state = products, action) => {
    switch (action.type) {
        case type:
            return produce(state, draft => {
                draft[action.payload].qty += 1
            })
        case 'cart/decrementqty':
            return produce(state, draft => {
                if (draft[action.payload].qty > 1) {
                    draft[action.payload].qty -= 1
                }
            })
        default:
            return state
    }
}

Here we are using immer js api called produce functions
and also we are using switch case....

can we skip immer js produce function and switch case , Yes we can

createReducer
.............
 Using createReducer u can write code using two patterns

1.Builder pattern
2.Map Object pattern
				

Builder Pattern:
import React from 'react';
import { configureStore, createAction, createReducer } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
import "./list.css"
import './index.css';

//////////////////////////////////////////////////////////////////////////////////
//builder pattern
const initialState = {
    value: 10
}
const increment = createAction('counter/increment')
const decrement = createAction('counter/decrement')
const incrementByAmount = createAction('counter/incrementByAmount')

const counterReducer = createReducer(initialState, builder => {
    //builder.addCase('counter/increment')
    builder
        .addCase(increment, (state, action) => {
            //biz logic:immer abstracted immutable logic
            state.value++
        })
        .addCase(decrement, (state, action) => {
            //biz logic:immer abstracted immutable logic
            state.value--
        })
        .addCase(incrementByAmount, (state, action) => {
            //biz logic:immer abstracted immutable logic
            state.value += action.payload
        })
        .addDefaultCase((state, action) => { })
})


const appStore = configureStore({
    reducer: {
        counter: counterReducer
    }
})


const Counter = props => {

    const value = useSelector(state => state.counter.value);
    const onIncrement = useDispatch();

    return <>
        <h1>Counter Increment Value : {value}</h1>
        <button onClick={() => {
            onIncrement(increment())
        }}>Increment</button>
        <button onClick={() => {
            onIncrement(decrement())
        }}>Decrement</button>
     <button onClick={() => {
            onIncrement(incrementByAmount(2))
        }}>IncrementByAmount</button>
    </>
}
/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Counter />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
.....................................................................................
			 createSlice

A function that accepts an inital state, an object of reducer functions, and a slice name, and automically generates actions ,action creators that correponds to the reducers and state.

createSlice has been built on the top of createReducer and createAction , immer 

import React from 'react';
import { configureStore, createSlice } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
import "./list.css"
import './index.css';

//////////////////////////////////////////////////////////////////////////////////
const initialState = {
    value: 10
}
//action  =  'sliceName/reducerName'
const counterSlice = createSlice({
    name: 'counter',
    initialState,
    reducers: {
        increment(state) {
            state.value++
        },
        decrement(state) {
            state.value--
        },
        incrementByAmount(state, action) {
            state.value += action.payload
        }
    }
})
console.log(counterSlice)
//extract reducers,actions from the slice 
export const { increment, decrement, incrementByAmount } = counterSlice.actions
//const counterReducer = counterSlice.reducer


const appStore = configureStore({
    reducer: {
        counter: counterSlice.reducer
    }
})


const Counter = props => {

    const value = useSelector(state => state.counter.value);
    const dispatch = useDispatch();

    return <>
        <h1>Counter Increment Value : {value}</h1>
        <button onClick={() => {
            dispatch(increment())
        }}>Increment</button>
        <button onClick={() => {
            dispatch(decrement())
        }}>Decrement</button>
        <button onClick={() => {
            dispatch(incrementByAmount(2))
        }}>IncrementByAmount</button>
    </>
}
/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Counter />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
.....................................................................................
			 Middlewares


Cross cutting concern.

eg:
logging


Regular work flow:
  store.dispatch(action)--------------------------|store-----Reducer---NewState

Middleware work flow:
 
			     middlewares
store.dispatch(action)------------|||--------------|store-----Reducer---NewState


configureStore
 has default middlewares already

=>Immutability check middleware
=>Serializability check middleware
=>Thunk -for async calls -

configStore({
 
 reducer: {},
 middleware:[thunk,logger]

})


eg:
we are going to use logger middleware

npm i redux-logger

import React from 'react';
import { configureStore, createSlice } from '@reduxjs/toolkit';
import { createRoot } from 'react-dom/client';
import { Provider, useSelector, useDispatch } from 'react-redux';
import logger from 'redux-logger'
import "./list.css"
import './index.css';

//////////////////////////////////////////////////////////////////////////////////
const initialState = {
    value: 10
}
//action  =  'sliceName/reducerName'
const counterSlice = createSlice({
    name: 'counter',
    initialState,
    reducers: {
        increment(state) {
            state.value++
        },
        decrement(state) {
            state.value--
        },
        incrementByAmount(state, action) {
            state.value += action.payload
        }
    }
})
console.log(counterSlice)
//extract reducers,actions from the slice 
export const { increment, decrement, incrementByAmount } = counterSlice.actions
//const counterReducer = counterSlice.reducer


const appStore = configureStore({
    reducer: {
        counter: counterSlice.reducer
    },
    //we have already predefined middlwares, now i want to add new middleware as well = existingmiddleware + new Middleware
    middleware: (getDefaultMiddleware) => {
        //console.log('Default Middlewares => ',getDefaultMiddleware())
        return getDefaultMiddleware().concat(logger)
    }
})


const Counter = props => {

    const value = useSelector(state => state.counter.value);
    const dispatch = useDispatch();

    return <>
        <h1>Counter Increment Value : {value}</h1>
        <button onClick={() => {
            dispatch(increment())
        }}>Increment</button>
        <button onClick={() => {
            dispatch(decrement())
        }}>Decrement</button>
        <button onClick={() => {
            dispatch(incrementByAmount(2))
        }}>IncrementByAmount</button>
    </>
}
/////////////////////////////////////////////////////////////////////////////////////
const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Counter />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
.....................................................................................
				Async work flows in redux
....................................................................................

In redux, async work flows are handled by "middlewares" only.

Async middlewares:
  It is third party middlewares used for any async work flows like timers,ajax calls...

Async middleware implementations:

libs
1.thunk - redux-thunk 
2.redux-promise
3.redux-saga
4.redux-observable

thunk is most populare and nativly integrated with redux toolkit.

...................................................................................
			  createAsyncThunk
...................................................................................

It is special reducer that accepts an action and callback function that returns a Promise.
It generates all promise lifecyle action types like "pending,fulfilled,rejected"

apis
  createAsyncThunk('type',function(){})

  createSlice() => will not have api calls. which is listening for data from thunk 


import { createSlice, createAsyncThunk,configureStore } from '@reduxjs/toolkit'
import { useEffect } from 'react'
import { useDispatch, useSelector,Provider } from 'react-redux'
import { createRoot } from 'react-dom/client';


const initialState = {
  entities: [],
  loading: false,
}

const getPosts = createAsyncThunk(
  'posts/getPosts',
  async (thunkAPI) => {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts').then(
    (data) => data.json()
  )
  return res
})


export const postSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {},
  extraReducers: {
    [getPosts.pending]: (state) => {
      state.loading = true
    },
    [getPosts.fulfilled]: (state, { payload }) => {
      state.loading = false
      state.entities = payload
    },
    [getPosts.rejected]: (state) => {
      state.loading = false
    },
  },
})

export const postReducer = postSlice.reducer

const appStore = configureStore({
    reducer: {
        posts: postReducer
    }
})
export default function Home() {
    const dispatch = useDispatch()
    const { entities, loading } = useSelector((state) => state.posts)
  
    useEffect(() => {
      dispatch(getPosts())
    }, [])
  
    if (loading) return <p>Loading...</p>
  
    return (
      <div>
        <h2>Blog Posts</h2>
        {entities.map((post) => (
          <p key={post.id}>{post.title}</p>
        ))}
      </div>
    )
  }

  const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Home />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
....................................................................................
import { createSlice, createAsyncThunk, configureStore } from '@reduxjs/toolkit'
import { useEffect } from 'react'
import { useDispatch, useSelector, Provider } from 'react-redux'
import { createRoot } from 'react-dom/client';


const initialState = {
    entities: [],
    error: null,
    loading: false,
}

//here it returns promise with different states pending,rejected,fullfiled
//middleware logic
const getPosts = createAsyncThunk(
    'posts/getPosts',
    async (input, thunkAPI) => {
        console.log('thunkApi', thunkAPI)
        const url = 'https://jsonplaceholder.typicode.com/posts'
        const res = await (await fetch(url)).json()
        return res
    }
)
//get By Id
const getPostsById = createAsyncThunk('posts/getPosts',
    async (id, thunkAPI) => {
        console.log('thunkApi', thunkAPI)
        const url = `https://jsonplaceholder.typicode.com/posts/${id}`
        const res = await (await fetch(url)).json()
        return res
    }
)

export const postSlice = createSlice({
    name: 'posts',
    initialState,
    reducers: {},
    extraReducers: {
        //'posts/requestStatus/pending'
        [getPosts.pending]: (state) => {
            console.log('pending')
            state.loading = true
        },
        //'posts/requestStatus/pending'

        [getPosts.fulfilled]: (state, { payload }) => {
            console.log('done')
            state.loading = false
            state.entities = payload
        },
        [getPosts.rejected]: (state) => {
            console.log('rejected')
            state.loading = false
            // state.error = action.error
        },
    },
})
export const postReducer = postSlice.reducer


const appStore = configureStore({
    reducer: {
        posts: postReducer
    }
})
export default function Posts() {
    const dispatch = useDispatch()
    const { entities, loading } = useSelector((state) => state.posts)

    useEffect(() => {
        //start async call - dispatch()
        dispatch(getPosts())
    }, [])

    if (loading) return <p>Loading...</p>

    return (
        <div>
            <h2>Blog Posts</h2>
            {entities.map((post) => (
                <p key={post.id}>{post.title}</p>
            ))}
        </div>
    )
}

const App = () => <div style={{ margin: 50, padding: 50, backgroundColor: 'ButtonFace' }}>
    <Provider store={appStore}>
        <h1 style={{ textAlign: 'center' }}>React Redux Integration App</h1>
        <Posts />
    </Provider>

</div>
const container = document.getElementById('root');
const root = createRoot(container);

root.render(<App />);
..............................&&&&&&&&&&&&&&&&&&&....................................
				Routing
....................................................................................

Routing + React+ Redux
			













